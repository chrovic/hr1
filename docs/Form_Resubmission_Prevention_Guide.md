# Form Resubmission Prevention Guide

## Problem
When users refresh the page after submitting a form, the browser resubmits the POST data, causing duplicate entries in the database.

## Solutions Implemented

### Method 1: POST-Redirect-GET (PRG) Pattern ⭐ **RECOMMENDED**

**How it works:**
- After successful POST processing, redirect to a GET page
- Prevents resubmission because refresh only repeats the GET request

**Implementation:**
```php
// After successful form processing
FormProtection::redirectAfterPost('?page=competency_models&action=list', 'Model created successfully!');

// Get flash messages on the redirected page
$flash = FormProtection::getFlashMessage();
$message = $flash['message'];
```

**Pros:**
- ✅ Most reliable method
- ✅ Works with all browsers
- ✅ No JavaScript required
- ✅ SEO friendly

**Cons:**
- ❌ Requires page reload
- ❌ Need to handle flash messages

---

### Method 2: Token-Based Protection

**How it works:**
- Generate unique token for each form
- Validate token on submission
- Consume token after use (prevent reuse)

**Implementation:**
```php
// Generate token
$token = FormProtection::generateToken();
FormProtection::storeToken('create_model', $token);

// In form
<input type="hidden" name="form_token" value="<?php echo $token; ?>">
<input type="hidden" name="form_name" value="create_model">

// Validate on submit
if (!FormProtection::validateAndConsumeToken($formName, $_POST['form_token'])) {
    $error = 'Invalid or expired form token.';
}
```

**Pros:**
- ✅ Prevents CSRF attacks
- ✅ Works without redirects
- ✅ Can be combined with other methods

**Cons:**
- ❌ Requires session management
- ❌ Tokens expire

---

### Method 3: Session-Based Duplicate Prevention

**How it works:**
- Store hash of submission data in session
- Check if same data was submitted recently
- Block duplicate submissions

**Implementation:**
```php
$modelData = [
    'name' => $_POST['name'],
    'description' => $_POST['description'],
    // ... other fields
];

if (FormProtection::preventDuplicateSession('create_model', $modelData)) {
    $error = 'Duplicate submission detected.';
} else {
    // Process form
}
```

**Pros:**
- ✅ Simple to implement
- ✅ No database changes needed
- ✅ Works with any form data

**Cons:**
- ❌ Session-based (lost on logout)
- ❌ Not persistent across sessions

---

### Method 4: Database-Based Duplicate Checking

**How it works:**
- Store submission hash in database
- Check for recent duplicates
- Block if found

**Implementation:**
```php
if (FormProtection::checkDuplicateSubmission('add_competency', $competencyData, $current_user['id'])) {
    $error = 'This competency was recently added.';
} else {
    // Process form
}
```

**Pros:**
- ✅ Most reliable
- ✅ Persistent across sessions
- ✅ Can track submission history

**Cons:**
- ❌ Requires database table
- ❌ More complex setup

---

### Method 5: JavaScript Prevention

**How it works:**
- Disable submit button after click
- Prevent multiple form submissions
- Show loading state

**Implementation:**
```javascript
// Auto-generated by FormProtection::getJavaScriptProtection()
form.addEventListener('submit', function(e) {
    const submitBtn = form.querySelector('button[type="submit"]');
    
    if (submitBtn && submitBtn.disabled) {
        e.preventDefault();
        return false;
    }
    
    // Disable submit button
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.value = 'Processing...';
    }
});
```

**Pros:**
- ✅ Immediate user feedback
- ✅ No server-side changes
- ✅ Good UX

**Cons:**
- ❌ Can be bypassed (JavaScript disabled)
- ❌ Not reliable for all scenarios

---

## Recommended Implementation Strategy

### For New Forms:
1. **Primary:** Use POST-Redirect-GET pattern
2. **Secondary:** Add token-based protection
3. **Enhancement:** Add JavaScript prevention

### For Existing Forms:
1. **Quick Fix:** Add JavaScript prevention
2. **Better:** Implement session-based duplicate prevention
3. **Best:** Refactor to POST-Redirect-GET pattern

### For Critical Forms:
1. **Use all methods combined:**
   - POST-Redirect-GET (primary)
   - Token validation (security)
   - Database duplicate checking (reliability)
   - JavaScript prevention (UX)

---

## Implementation Examples

### Basic Form Protection
```php
// 1. Generate token
$token = FormProtection::generateToken();
FormProtection::storeToken('my_form', $token);

// 2. In form
<form method="POST">
    <input type="hidden" name="form_token" value="<?php echo $token; ?>">
    <input type="hidden" name="form_name" value="my_form">
    <!-- form fields -->
    <button type="submit">Submit</button>
</form>

// 3. Process form
if (FormProtection::validateAndConsumeToken('my_form', $_POST['form_token'])) {
    // Process form
    FormProtection::redirectAfterPost('success.php', 'Form submitted!');
}
```

### Advanced Form Protection
```php
// Multiple protection layers
if ($_POST) {
    $isDuplicate = false;
    
    // 1. Token validation
    if (!FormProtection::validateAndConsumeToken('my_form', $_POST['form_token'])) {
        $error = 'Invalid form token.';
        $isDuplicate = true;
    }
    
    // 2. Session duplicate check
    if (!$isDuplicate && FormProtection::preventDuplicateSession('my_form', $_POST)) {
        $error = 'Duplicate submission detected.';
        $isDuplicate = true;
    }
    
    // 3. Database duplicate check
    if (!$isDuplicate && FormProtection::checkDuplicateSubmission('my_action', $_POST, $userId)) {
        $error = 'This action was recently performed.';
        $isDuplicate = true;
    }
    
    // 4. Process if not duplicate
    if (!$isDuplicate) {
        // Process form
        FormProtection::redirectAfterPost('success.php', 'Success!');
    }
}
```

---

## Testing Your Implementation

### Test Cases:
1. **Normal submission** - Should work
2. **Page refresh after submit** - Should not duplicate
3. **Back button + resubmit** - Should not duplicate
4. **Multiple rapid clicks** - Should not duplicate
5. **JavaScript disabled** - Should still work
6. **Session expired** - Should handle gracefully

### Test Script:
```php
// Test duplicate prevention
$testData = ['name' => 'Test', 'email' => 'test@example.com'];

// First submission
$result1 = FormProtection::preventDuplicateSession('test_form', $testData);
echo "First submission: " . ($result1 ? "BLOCKED" : "ALLOWED") . "\n";

// Second submission (should be blocked)
$result2 = FormProtection::preventDuplicateSession('test_form', $testData);
echo "Second submission: " . ($result2 ? "BLOCKED" : "ALLOWED") . "\n";
```

---

## Best Practices

1. **Always use POST-Redirect-GET for critical forms**
2. **Combine multiple methods for maximum protection**
3. **Test with JavaScript disabled**
4. **Provide clear error messages**
5. **Log duplicate attempts for monitoring**
6. **Consider user experience (don't be too restrictive)**
7. **Clean up old tokens and session data regularly**

---

## Common Issues and Solutions

### Issue: "Form token expired"
**Solution:** Regenerate token on page load, don't reuse tokens

### Issue: "Still getting duplicates"
**Solution:** Check if you're using POST-Redirect-GET properly

### Issue: "JavaScript not working"
**Solution:** Ensure JavaScript is loaded after DOM is ready

### Issue: "Session data lost"
**Solution:** Use database-based duplicate checking for persistence

---

## Conclusion

The most effective approach is to combine multiple methods:
- **POST-Redirect-GET** for primary protection
- **Token validation** for security
- **JavaScript prevention** for user experience
- **Database checking** for critical forms

This provides defense in depth against form resubmission issues.


